"""
ONIX 3.0 export functionality for retail distribution.

Generates ONIX XML files from EPUB metadata for book industry distribution.
Supports major retailer requirements and standards compliance.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from datetime import datetime, date
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Any
from xml.dom import minidom
from xml.etree import ElementTree as ET

from .metadata import EpubMetadata

logger = logging.getLogger(__name__)


class OnixProductForm(Enum):
    """ONIX Product Form codes."""
    EBOOK = "ED"  # Digital/Electronic book
    AUDIOBOOK = "AJ"  # Digital audiobook
    PRINT_BOOK = "BB"  # Hardback book
    PAPERBACK = "BC"  # Paperback


class OnixProductFormDetail(Enum):
    """ONIX Product Form Detail codes."""
    EPUB = "E101"  # EPUB
    PDF = "E107"   # PDF
    MOBI = "E116"  # Kindle/Mobipocket
    HTML = "E127"  # HTML


class OnixAvailabilityCode(Enum):
    """ONIX Availability codes."""
    AVAILABLE = "21"  # Available
    NOT_YET_AVAILABLE = "10"  # Not yet available
    WITHDRAWN = "31"  # Withdrawn from sale


class OnixPriceType(Enum):
    """ONIX Price Type codes."""
    CONSUMER_RETAIL = "01"  # RRP excluding tax
    CONSUMER_RETAIL_INCL_TAX = "02"  # RRP including tax
    WHOLESALE = "03"  # Fixed retail price


@dataclass
class OnixContributor:
    """ONIX contributor information."""
    role: str  # ONIX role code (A01=Author, etc.)
    name: str
    biographical_note: str = ""
    website: str = ""


@dataclass
class OnixSubject:
    """ONIX subject classification."""
    scheme: str  # BISAC, BIC, Keywords, etc.
    code: str = ""
    heading: str = ""


@dataclass
class OnixPrice:
    """ONIX price information."""
    amount: float
    currency: str = "USD"
    price_type: OnixPriceType = OnixPriceType.CONSUMER_RETAIL
    territory: str = "WORLD"


@dataclass
class OnixConfig:
    """Configuration for ONIX export."""
    sender_id: str = "docx2shelf"
    sender_name: str = "Docx2Shelf"
    message_note: str = "Generated by Docx2Shelf"
    include_sales_rights: bool = True
    include_marketing_copy: bool = True
    default_availability: OnixAvailabilityCode = OnixAvailabilityCode.AVAILABLE
    default_product_form: OnixProductForm = OnixProductForm.EBOOK
    default_format_detail: OnixProductFormDetail = OnixProductFormDetail.EPUB


@dataclass
class OnixRecord:
    """Complete ONIX product record."""
    # Required fields
    record_reference: str
    notification_type: str = "03"  # Notification confirmed on publication
    product_form: OnixProductForm = OnixProductForm.EBOOK
    product_form_detail: OnixProductFormDetail = OnixProductFormDetail.EPUB

    # Identifiers
    isbn: str = ""
    proprietary_id: str = ""

    # Title information
    title: str = ""
    subtitle: str = ""
    title_prefix: str = ""

    # Contributors
    contributors: List[OnixContributor] = field(default_factory=list)

    # Series information
    series_title: str = ""
    series_number: str = ""

    # Edition information
    edition_type: str = ""
    edition_number: str = ""

    # Publishing details
    publisher_name: str = ""
    publishing_date: Optional[date] = None
    copyright_year: str = ""

    # Description
    description: str = ""
    short_description: str = ""

    # Subject classification
    subjects: List[OnixSubject] = field(default_factory=list)

    # Audience information
    audience_age_from: Optional[int] = None
    audience_age_to: Optional[int] = None

    # Sales information
    availability: OnixAvailabilityCode = OnixAvailabilityCode.AVAILABLE
    prices: List[OnixPrice] = field(default_factory=list)

    # Technical details
    file_size_kb: Optional[int] = None
    page_count: Optional[int] = None

    # Marketing
    keywords: List[str] = field(default_factory=list)
    marketing_text: str = ""


class OnixExporter:
    """Exports EPUB metadata to ONIX 3.0 XML format."""

    def __init__(self, config: Optional[OnixConfig] = None):
        self.config = config or OnixConfig()

    def export_metadata(self, metadata: EpubMetadata, output_path: Path, **kwargs) -> Path:
        """
        Export EPUB metadata to ONIX XML file.

        Args:
            metadata: EPUB metadata to export
            output_path: Path for output ONIX file
            **kwargs: Additional metadata not in EpubMetadata

        Returns:
            Path to created ONIX file
        """
        # Convert metadata to ONIX record
        onix_record = self._metadata_to_onix_record(metadata, **kwargs)

        # Generate ONIX XML
        xml_content = self._generate_onix_xml([onix_record])

        # Write to file
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(xml_content, encoding='utf-8')

        logger.info(f"Generated ONIX file: {output_path}")
        return output_path

    def _metadata_to_onix_record(self, metadata: EpubMetadata, **kwargs) -> OnixRecord:
        """Convert EpubMetadata to OnixRecord."""

        # Generate record reference
        record_ref = metadata.isbn or metadata.uuid or f"docx2shelf-{datetime.now().strftime('%Y%m%d%H%M%S')}"

        # Create base record
        record = OnixRecord(
            record_reference=record_ref,
            isbn=metadata.isbn or "",
            title=metadata.title,
            publisher_name=metadata.publisher or "",
            description=metadata.description or "",
            copyright_year=str(metadata.pubdate.year) if metadata.pubdate else "",
            publishing_date=metadata.pubdate
        )

        # Handle contributors
        if metadata.author:
            record.contributors.append(OnixContributor(
                role="A01",  # Author
                name=metadata.author
            ))

        # Handle additional contributors from kwargs
        contributors = kwargs.get('contributors', [])
        for contrib in contributors:
            if isinstance(contrib, dict):
                record.contributors.append(OnixContributor(
                    role=contrib.get('role', 'A01'),
                    name=contrib.get('name', ''),
                    biographical_note=contrib.get('bio', ''),
                    website=contrib.get('website', '')
                ))

        # Handle series information
        if metadata.series:
            record.series_title = metadata.series
            if metadata.series_index:
                record.series_number = str(metadata.series_index)

        # Handle subjects (BISAC codes and keywords)
        bisac_codes = kwargs.get('bisac_codes', [])
        for bisac_code in bisac_codes:
            if isinstance(bisac_code, str):
                record.subjects.append(OnixSubject(
                    scheme="10",  # BISAC Subject Heading
                    code=bisac_code
                ))
            elif isinstance(bisac_code, dict):
                record.subjects.append(OnixSubject(
                    scheme="10",
                    code=bisac_code.get('code', ''),
                    heading=bisac_code.get('heading', '')
                ))

        # Add keywords as subjects
        all_keywords = list(metadata.keywords) + list(metadata.subjects)
        if all_keywords:
            record.subjects.append(OnixSubject(
                scheme="20",  # Keywords
                heading="; ".join(all_keywords)
            ))

        # Handle pricing
        prices = kwargs.get('prices', [])
        for price_info in prices:
            if isinstance(price_info, dict):
                record.prices.append(OnixPrice(
                    amount=float(price_info.get('amount', 0)),
                    currency=price_info.get('currency', 'USD'),
                    price_type=OnixPriceType(price_info.get('type', '01')),
                    territory=price_info.get('territory', 'WORLD')
                ))

        # Handle age ranges
        age_range = kwargs.get('age_range', {})
        if age_range:
            record.audience_age_from = age_range.get('from')
            record.audience_age_to = age_range.get('to')

        # Handle technical details
        record.file_size_kb = kwargs.get('file_size_kb')
        record.page_count = kwargs.get('page_count')

        # Handle marketing text
        record.marketing_text = kwargs.get('marketing_text', '')
        record.short_description = kwargs.get('short_description', metadata.description or '')

        return record

    def _generate_onix_xml(self, records: List[OnixRecord]) -> str:
        """Generate ONIX 3.0 XML from records."""

        # Create root element
        root = ET.Element("ONIXMessage")
        root.set("release", "3.0")

        # Add header
        header = ET.SubElement(root, "Header")

        sender = ET.SubElement(header, "Sender")
        sender_id = ET.SubElement(sender, "SenderIdentifier")
        ET.SubElement(sender_id, "SenderIDType").text = "01"  # Proprietary
        ET.SubElement(sender_id, "IDValue").text = self.config.sender_id
        ET.SubElement(sender, "SenderName").text = self.config.sender_name

        ET.SubElement(header, "SentDateTime").text = datetime.now().strftime("%Y%m%dT%H%M%S")
        ET.SubElement(header, "MessageNote").text = self.config.message_note

        # Add records
        for record in records:
            product = self._create_product_element(record)
            root.append(product)

        # Convert to pretty XML string
        rough_string = ET.tostring(root, encoding='unicode')
        reparsed = minidom.parseString(rough_string)
        return reparsed.toprettyxml(indent="  ")

    def _create_product_element(self, record: OnixRecord) -> ET.Element:
        """Create Product element from OnixRecord."""

        product = ET.Element("Product")

        # Record reference
        ET.SubElement(product, "RecordReference").text = record.record_reference
        ET.SubElement(product, "NotificationType").text = record.notification_type

        # Product identifiers
        if record.isbn:
            prod_id = ET.SubElement(product, "ProductIdentifier")
            ET.SubElement(prod_id, "ProductIDType").text = "15"  # ISBN-13
            ET.SubElement(prod_id, "IDValue").text = record.isbn

        if record.proprietary_id:
            prod_id = ET.SubElement(product, "ProductIdentifier")
            ET.SubElement(prod_id, "ProductIDType").text = "01"  # Proprietary
            ET.SubElement(prod_id, "IDValue").text = record.proprietary_id

        # Descriptive detail
        desc_detail = ET.SubElement(product, "DescriptiveDetail")

        ET.SubElement(desc_detail, "ProductComposition").text = "00"  # Single-item retail product
        ET.SubElement(desc_detail, "ProductForm").text = record.product_form.value

        if record.product_form_detail:
            ET.SubElement(desc_detail, "ProductFormDetail").text = record.product_form_detail.value

        # Title detail
        title_detail = ET.SubElement(desc_detail, "TitleDetail")
        ET.SubElement(title_detail, "TitleType").text = "01"  # Distinctive title

        title_element = ET.SubElement(title_detail, "TitleElement")
        ET.SubElement(title_element, "TitleElementLevel").text = "01"  # Product level

        if record.title_prefix:
            ET.SubElement(title_element, "TitlePrefix").text = record.title_prefix

        ET.SubElement(title_element, "TitleWithoutPrefix").text = record.title

        if record.subtitle:
            ET.SubElement(title_element, "Subtitle").text = record.subtitle

        # Contributors
        for contributor in record.contributors:
            contrib_elem = ET.SubElement(desc_detail, "Contributor")
            ET.SubElement(contrib_elem, "SequenceNumber").text = str(record.contributors.index(contributor) + 1)
            ET.SubElement(contrib_elem, "ContributorRole").text = contributor.role
            ET.SubElement(contrib_elem, "PersonName").text = contributor.name

            if contributor.biographical_note:
                ET.SubElement(contrib_elem, "BiographicalNote").text = contributor.biographical_note

            if contributor.website:
                website_elem = ET.SubElement(contrib_elem, "Website")
                ET.SubElement(website_elem, "WebsiteRole").text = "01"  # Author website
                ET.SubElement(website_elem, "WebsiteLink").text = contributor.website

        # Series information
        if record.series_title:
            collection = ET.SubElement(desc_detail, "Collection")
            ET.SubElement(collection, "CollectionType").text = "10"  # Series

            title_detail = ET.SubElement(collection, "TitleDetail")
            ET.SubElement(title_detail, "TitleType").text = "01"

            title_element = ET.SubElement(title_detail, "TitleElement")
            ET.SubElement(title_element, "TitleElementLevel").text = "02"  # Collection level
            ET.SubElement(title_element, "TitleWithoutPrefix").text = record.series_title

            if record.series_number:
                ET.SubElement(title_element, "PartNumber").text = record.series_number

        # Subject information
        for subject in record.subjects:
            subject_elem = ET.SubElement(desc_detail, "Subject")
            ET.SubElement(subject_elem, "SubjectSchemeIdentifier").text = subject.scheme

            if subject.code:
                ET.SubElement(subject_elem, "SubjectCode").text = subject.code

            if subject.heading:
                ET.SubElement(subject_elem, "SubjectHeadingText").text = subject.heading

        # Audience information
        if record.audience_age_from is not None or record.audience_age_to is not None:
            audience = ET.SubElement(desc_detail, "Audience")
            ET.SubElement(audience, "AudienceCodeType").text = "17"  # Reading age

            if record.audience_age_from is not None:
                ET.SubElement(audience, "AudienceCodeValue").text = f"{record.audience_age_from:02d}"

            if record.audience_age_to is not None:
                audience_range = ET.SubElement(audience, "AudienceRange")
                ET.SubElement(audience_range, "AudienceRangeQualifier").text = "17"  # Reading age
                ET.SubElement(audience_range, "AudienceRangePrecision").text = "03"  # From... to...

                range_value = ET.SubElement(audience_range, "AudienceRangeValue")
                ET.SubElement(range_value, "AudienceRangeValue").text = str(record.audience_age_from or 0)

                range_value2 = ET.SubElement(audience_range, "AudienceRangeValue")
                ET.SubElement(range_value2, "AudienceRangeValue").text = str(record.audience_age_to)

        # Collateral detail (descriptions, marketing text)
        if record.description or record.short_description or record.marketing_text:
            collateral = ET.SubElement(product, "CollateralDetail")

            if record.description:
                text_content = ET.SubElement(collateral, "TextContent")
                ET.SubElement(text_content, "TextType").text = "03"  # Description
                ET.SubElement(text_content, "ContentAudience").text = "00"  # Unrestricted
                ET.SubElement(text_content, "Text").text = record.description

            if record.short_description and record.short_description != record.description:
                text_content = ET.SubElement(collateral, "TextContent")
                ET.SubElement(text_content, "TextType").text = "02"  # Short description/annotation
                ET.SubElement(text_content, "ContentAudience").text = "00"
                ET.SubElement(text_content, "Text").text = record.short_description

            if record.marketing_text:
                text_content = ET.SubElement(collateral, "TextContent")
                ET.SubElement(text_content, "TextType").text = "23"  # Description for Reader
                ET.SubElement(text_content, "ContentAudience").text = "00"
                ET.SubElement(text_content, "Text").text = record.marketing_text

        # Publishing detail
        pub_detail = ET.SubElement(product, "PublishingDetail")

        if record.publisher_name:
            publisher = ET.SubElement(pub_detail, "Publisher")
            ET.SubElement(publisher, "PublishingRole").text = "01"  # Publisher
            ET.SubElement(publisher, "PublisherName").text = record.publisher_name

        if record.publishing_date:
            pub_date = ET.SubElement(pub_detail, "PublishingDate")
            ET.SubElement(pub_date, "PublishingDateRole").text = "01"  # Publication date
            ET.SubElement(pub_date, "Date").text = record.publishing_date.strftime("%Y%m%d")

        if record.copyright_year:
            copy_stmt = ET.SubElement(pub_detail, "CopyrightStatement")
            ET.SubElement(copy_stmt, "CopyrightYear").text = record.copyright_year

        # Product supply
        prod_supply = ET.SubElement(product, "ProductSupply")

        supply_detail = ET.SubElement(prod_supply, "SupplyDetail")
        ET.SubElement(supply_detail, "Supplier")

        # Product availability
        availability = ET.SubElement(supply_detail, "ProductAvailability")
        ET.SubElement(availability, "ProductAvailability").text = record.availability.value

        # Prices
        for price in record.prices:
            price_elem = ET.SubElement(supply_detail, "Price")
            ET.SubElement(price_elem, "PriceType").text = price.price_type.value
            ET.SubElement(price_elem, "PriceAmount").text = f"{price.amount:.2f}"
            ET.SubElement(price_elem, "CurrencyCode").text = price.currency

            if price.territory != "WORLD":
                territory_elem = ET.SubElement(price_elem, "Territory")
                ET.SubElement(territory_elem, "CountriesIncluded").text = price.territory

        return product

    def validate_onix(self, onix_path: Path) -> List[str]:
        """
        Validate ONIX file against ONIX 3.0 schema.

        Returns:
            List of validation errors (empty if valid)
        """
        errors = []

        try:
            # Parse XML
            tree = ET.parse(onix_path)
            root = tree.getroot()

            # Basic validation checks
            if root.tag != "ONIXMessage":
                errors.append("Root element must be ONIXMessage")

            # Check for required header elements
            header = root.find("Header")
            if header is None:
                errors.append("Header element is required")
            else:
                if header.find("Sender") is None:
                    errors.append("Header/Sender is required")
                if header.find("SentDateTime") is None:
                    errors.append("Header/SentDateTime is required")

            # Check products
            products = root.findall("Product")
            if not products:
                errors.append("At least one Product is required")

            for i, product in enumerate(products):
                product_errors = self._validate_product(product)
                for error in product_errors:
                    errors.append(f"Product {i+1}: {error}")

        except ET.ParseError as e:
            errors.append(f"XML parsing error: {e}")
        except Exception as e:
            errors.append(f"Validation error: {e}")

        return errors

    def _validate_product(self, product: ET.Element) -> List[str]:
        """Validate a single Product element."""
        errors = []

        # Required elements
        required_elements = [
            "RecordReference",
            "NotificationType",
            "DescriptiveDetail",
            "PublishingDetail",
            "ProductSupply"
        ]

        for elem_name in required_elements:
            if product.find(elem_name) is None:
                errors.append(f"Required element {elem_name} is missing")

        # Check DescriptiveDetail
        desc_detail = product.find("DescriptiveDetail")
        if desc_detail is not None:
            if desc_detail.find("ProductForm") is None:
                errors.append("DescriptiveDetail/ProductForm is required")

            if desc_detail.find("TitleDetail") is None:
                errors.append("DescriptiveDetail/TitleDetail is required")

        return errors


def export_onix_from_metadata(
    metadata: EpubMetadata,
    output_path: Path,
    config: Optional[OnixConfig] = None,
    **kwargs
) -> Path:
    """
    Export EPUB metadata to ONIX 3.0 XML file.

    Args:
        metadata: EPUB metadata to export
        output_path: Path for output ONIX file
        config: ONIX export configuration
        **kwargs: Additional metadata (prices, contributors, etc.)

    Returns:
        Path to created ONIX file
    """
    exporter = OnixExporter(config)
    return exporter.export_metadata(metadata, output_path, **kwargs)