   1: from __future__ import annotations
   1: 
   1: import argparse
   1: import sys
   1: from pathlib import Path
   1: from typing import Optional
   1: 
   1: from .metadata import BuildOptions, EpubMetadata, build_output_filename, parse_date
   1: from .utils import (
   1:     prompt,
   1:     prompt_choice,
   1:     prompt_bool,
   1:     prompt_select,
   1:     sanitize_filename,
   1:     parse_kv_file,
   1: )
   1: 
   1: 
   1: def _arg_parser() -> argparse.ArgumentParser:
   1:     p = argparse.ArgumentParser(
   1:         prog="docx2shelf",
   1:         description="Convert a DOCX manuscript into a valid EPUB 3 (offline)",
   1:     )
   1:     sub = p.add_subparsers(dest="command", required=False)
   1: 
   1:     b = sub.add_parser("build", help="Build an EPUB from inputs")
   1:     b.add_argument("--docx", type=str, help="Path to manuscript .docx")
   1:     b.add_argument("--cover", type=str, help="Path to cover image (jpg/png)")
   1:     b.add_argument("--title", type=str, help="Book title")
   1:     b.add_argument("--author", type=str, default="Riley E. Antrobus", help="Author name")
   1:     b.add_argument("--seriesName", type=str, help="Series name (optional)")
   1:     b.add_argument("--seriesIndex", type=str, help="Series index/number (optional)")
   1:     b.add_argument("--title-sort", dest="title_sort", type=str, help="Calibre title sort (optional)")
   1:     b.add_argument("--author-sort", dest="author_sort", type=str, help="Calibre author sort (optional)")
   1:     b.add_argument("--description", type=str, help="Long description (optional)")
   1:     b.add_argument("--isbn", type=str, help="ISBN-13 digits only (optional)")
   1:     b.add_argument("--language", type=str, default="en", help="Language code, e.g., en")
   1:     b.add_argument("--publisher", type=str, help="Publisher (optional)")
   1:     b.add_argument("--pubdate", type=str, help="Publication date ISO YYYY-MM-DD (optional)")
   1:     b.add_argument("--uuid", type=str, help="UUID to use when no ISBN (optional)")
   1:     b.add_argument("--subjects", type=str, help="Comma-separated subjects")
   1:     b.add_argument("--keywords", type=str, help="Comma-separated keywords")
   1: 
   1:     b.add_argument(
   1:         "--split-at",
   1:         choices=["h1", "h2", "pagebreak"],
   1:         default="h1",
   1:         help="How to split content into XHTML files",
   1:     )
   1:     b.add_argument(
   1:         "--theme",
   1:         choices=["serif", "sans", "printlike"],
   1:         default="serif",
   1:         help="Base CSS theme",
   1:     )
   1:     b.add_argument("--embed-fonts", type=str, help="Directory of TTF/OTF to embed")
   1:     b.add_argument("--hyphenate", choices=["on", "off"], default="on")
   1:     b.add_argument("--justify", choices=["on", "off"], default="on")
   1:     b.add_argument("--toc-depth", type=int, default=2)
   1:     b.add_argument("--page-list", choices=["on", "off"], default="off")
   1:     b.add_argument("--css", type=str, help="Path to extra CSS to merge (optional)")
   1:     b.add_argument("--page-numbers", choices=["on", "off"], default="off")
   1:     b.add_argument("--epub-version", type=str, default="3")
   1:     b.add_argument("--cover-scale", choices=["contain", "cover"], default="contain")
   1: 
   1:     b.add_argument("--dedication", type=str, help="Path to plain-text dedication (optional)")
   1:     b.add_argument("--ack", type=str, help="Path to plain-text acknowledgements (optional)")
   1: 
   1:     b.add_argument("--output", type=str, help="Output .epub path (optional)")
   1:     b.add_argument("--inspect", action="store_true", help="Emit inspect folder with sources")
   1:     b.add_argument("--dry-run", action="store_true", help="Print planned manifest/spine only")
   1:     b.add_argument("--epubcheck", choices=["on", "off"], default="on", help="Validate with EPUBCheck if available")
   1:     b.add_argument("--no-prompt", action="store_true", help="Do not prompt; use provided defaults and flags only")
   1: 
   1:     t = sub.add_parser("init-metadata", help="Generate a metadata.txt template next to the DOCX")
   1:     t.add_argument("--docx", type=str, required=True, help="Path to manuscript .docx")
   1:     t.add_argument("--cover", type=str, help="Optional default cover path")
   1:     t.add_argument("--output", type=str, help="Optional path to write template (defaults to DOCX folder/metadata.txt)")
   1:     t.add_argument("--force", action="store_true", help="Overwrite existing file if present")
   1: 
   1:     return p
   1: 
   1: 
   1: def _apply_metadata_dict(args: argparse.Namespace, md: dict, base_dir: Path | None) -> None:
   1:     if not md:
   1:         return
   1:     def get(k: str):
   1:         # allow simple aliases
   1:         aliases = {
   1:             "series": "seriesName",
   1:             "seriesname": "seriesName",
   1:             "series_index": "seriesIndex",
   1:             "seriesindex": "seriesIndex",
   1:             "title-sort": "title_sort",
   1:             "author-sort": "author_sort",
   1:         }
   1:         k2 = aliases.get(k.lower(), k)
   1:         return md.get(k, md.get(k.lower(), md.get(k2, md.get(k2.lower()))))
   1: 
   1:     def pathify(val: str | None) -> str | None:
   1:         if not val:
   1:             return None
   1:         p = Path(val)
   1:         if not p.is_absolute() and base_dir:
   1:             p = (base_dir / p).resolve()
   1:         return str(p)
   1: 
   1:     # Core (file overrides defaults; CLI may still override if passed explicitly)
   1:     if (not args.docx) and get("docx"): args.docx = get("docx")
   1:     if (not args.cover) and get("cover"): args.cover = pathify(get("cover"))
   1:     if (not args.title) and get("title"): args.title = get("title")
   1:     if (not args.author) and get("author"): args.author = get("author")
   1:     if (not args.language) and get("language"): args.language = get("language")
   1:     # Optional metadata
   1:     if get("seriesname") or get("series"):
   1:         args.seriesName = get("seriesname") or get("series")
   1:     if get("seriesindex"):
   1:         args.seriesIndex = get("seriesindex")
   1:     if get("title_sort") or get("title-sort"):
   1:         setattr(args, "title_sort", get("title_sort") or get("title-sort"))
   1:     if get("author_sort") or get("author-sort"):
   1:         setattr(args, "author_sort", get("author_sort") or get("author-sort"))
   1:     if get("description"): args.description = get("description")
   1:     if get("isbn"): args.isbn = get("isbn")
   1:     if get("publisher"): args.publisher = get("publisher")
   1:     if get("pubdate"): args.pubdate = get("pubdate")
   1:     if get("uuid"): args.uuid = get("uuid")
   1:     if get("subjects"): args.subjects = get("subjects")
   1:     if get("keywords"): args.keywords = get("keywords")
   1:     # Conversion/layout
   1:     if (args.split_at in (None, "", "h1")) and (get("split_at") or get("split-at")):
   1:         args.split_at = get("split_at") or get("split-at")
   1:     if (args.theme in (None, "", "serif")) and get("theme"):
   1:         args.theme = get("theme")
   1:     if (args.hyphenate in (None, "", "on")) and get("hyphenate"):
   1:         args.hyphenate = get("hyphenate")
   1:     if (args.justify in (None, "", "on")) and get("justify"):
   1:         args.justify = get("justify")
   1:     try:
   1:         if get("toc_depth") and not getattr(args, "toc_depth_set", False):
   1:             args.toc_depth = int(get("toc_depth"))
   1:             setattr(args, "toc_depth_set", True)
   1:     except Exception:
   1:         pass
   1:     if (getattr(args, "toc_depth", None) in (None, 2)) and get("toc_depth"):
   1:         try: args.toc_depth = int(get("toc_depth"))
   1:         except Exception: pass
   1:     if (args.page_list in (None, "", "off")) and (get("page_list") or get("page-list")):
   1:         args.page_list = get("page_list") or get("page-list")
   1:     if (args.page_numbers in (None, "", "off")) and (get("page_numbers") or get("page-numbers")):
   1:         args.page_numbers = get("page_numbers") or get("page-numbers")
   1:     if (args.cover_scale in (None, "", "contain")) and (get("cover_scale") or get("cover-scale")):
   1:         args.cover_scale = get("cover_scale") or get("cover-scale")
   1:     # Assets
   1:     if (getattr(args, "css", None) in (None, "")) and get("css"): args.css = pathify(get("css"))
   1:     if (getattr(args, "embed_fonts", None) in (None, "")) and (get("embed_fonts") or get("embed-fonts")):
   1:         args.embed_fonts = pathify(get("embed_fonts") or get("embed-fonts"))
   1:     if (getattr(args, "dedication", None) in (None, "")) and get("dedication"): args.dedication = pathify(get("dedication"))
   1:     if (getattr(args, "ack", None) in (None, "")) and (get("ack") or get("acknowledgements") or get("acknowledgments")):
   1:         args.ack = pathify(get("ack") or get("acknowledgements") or get("acknowledgments"))
   1:     # Output
   1:     if (getattr(args, "output", None) in (None, "")) and get("output"): args.output = pathify(get("output"))
   1:     if (getattr(args, "epubcheck", None) in (None, "on")) and get("epubcheck"): args.epubcheck = get("epubcheck")
   1: 
   1: 
   1: def _print_checklist(args: argparse.Namespace) -> None:
   1:     def checked(val) -> str:
   1:         return "[x]" if (val is not None and str(val).strip() != "") else "[ ]"
   1: 
   1:     items = [
   1:         ("DOCX", args.docx),
   1:         ("Cover", args.cover),
   1:         ("Title", args.title),
   1:         ("Author", args.author),
   1:         ("Language", args.language),
   1:         ("Series", args.seriesName),
   1:         ("Series Index", args.seriesIndex),
   1:         ("Title Sort", getattr(args, "title_sort", None)),
   1:         ("Author Sort", getattr(args, "author_sort", None)),
   1:         ("Description", args.description),
   1:         ("ISBN", args.isbn),
   1:         ("Publisher", args.publisher),
   1:         ("PubDate", args.pubdate),
   1:         ("UUID", args.uuid),
   1:         ("Subjects", args.subjects),
   1:         ("Keywords", args.keywords),
   1:         ("Split At", args.split_at),
   1:         ("Theme", args.theme),
   1:         ("Hyphenate", args.hyphenate),
   1:         ("Justify", args.justify),
   1:         ("ToC Depth", getattr(args, "toc_depth", None)),
   1:         ("Page List", args.page_list),
   1:         ("Page Numbers", args.page_numbers),
   1:         ("Cover Scale", args.cover_scale),
   1:         ("Extra CSS", args.css),
   1:         ("Fonts Dir", args.embed_fonts),
   1:         ("Dedication", args.dedication),
   1:         ("Acknowledgements", args.ack),
   1:         ("EPUBCheck", getattr(args, "epubcheck", None)),
   1:         ("Output", args.output),
   1:     ]
   1:     print("\n== Metadata Checklist ==")
   1:     print("(Press Enter to skip/keep current when prompted)\n")
   1:     for name, val in items:
   1:         display = str(val) if val is not None and str(val).strip() != "" else "—"
   1:         print(f" {checked(val)} {name}: {display}")
   1:     print("")
   1: 
   1: 
   1: def _prompt_missing(args: argparse.Namespace) -> argparse.Namespace:
   1:     # Ask interactively for anything not provided on CLI.
   1:     import sys as _sys
   1:     interactive = (not getattr(args, "no_prompt", False)) and _sys.stdin.isatty()
   1: 
   1:     # Attempt to pre-load metadata from metadata.txt
   1:     md_loaded = False
   1:     # Prefer docx directory if docx is already provided
   1:     if args.docx:
   1:         try:
   1:             md_path = Path(args.docx).expanduser()
   1:             md_dir = md_path.parent if md_path.suffix else Path.cwd()
   1:             mfile = md_dir / "metadata.txt"
   1:             if mfile.exists():
   1:                 _apply_metadata_dict(args, parse_kv_file(mfile), md_dir)
   1:                 md_loaded = True
   1:         except Exception:
   1:             pass
   1:     # If no docx yet, try CWD metadata.txt and let it specify docx
   1:     if not md_loaded:
   1:         mfile = Path.cwd() / "metadata.txt"
   1:         if mfile.exists():
   1:             md = parse_kv_file(mfile)
   1:             _apply_metadata_dict(args, md, Path.cwd())
   1:             # If docx now set, and a different dir holds another metadata.txt, merge it
   1:             if args.docx:
   1:                 d = Path(args.docx).expanduser().resolve().parent
   1:                 if d != Path.cwd() and (d / "metadata.txt").exists():
   1:                     _apply_metadata_dict(args, parse_kv_file(d / "metadata.txt"), d)
   1: 
   1:     # Auto-detect DOCX in current working directory when not provided
   1:     if not args.docx:
   1:         cwd = Path.cwd()
   1:         candidates = sorted([p.name for p in cwd.glob("*.docx") if p.is_file()])
   1:         if len(candidates) == 1:
   1:             args.docx = candidates[0]
   1:         elif len(candidates) > 1 and interactive:
   1:             # Let user choose among files found in current directory
   1:             args.docx = prompt_select("Found multiple DOCX files in this folder:", candidates, default_index=1)
   1:         # else: leave empty for prompt below or non-interactive error handling
   1: 
   1:     # After potential docx selection, attempt to auto-detect or pick common cover file name
   1:     if not args.cover and args.docx:
   1:         docx_path_tmp = Path(args.docx).expanduser().resolve()
   1:         docx_dir_tmp = docx_path_tmp.parent
   1:         # Enumerate available image files (jpg/jpeg/png)
   1:         cover_candidates = [
   1:             p.name for p in sorted(docx_dir_tmp.glob("*.jpg"))
   1:         ] + [
   1:             p.name for p in sorted(docx_dir_tmp.glob("*.jpeg"))
   1:         ] + [
   1:             p.name for p in sorted(docx_dir_tmp.glob("*.png"))
   1:         ]
   1:         # Prefer conventional cover names first if present
   1:         conventional = [n for n in ("cover.jpg", "cover.jpeg", "cover.png") if (docx_dir_tmp / n).is_file()]
   1:         if conventional:
   1:             # Move conventional names to the front of the candidate list
   1:             cover_candidates = list(dict.fromkeys(conventional + cover_candidates))
   1:         if interactive and cover_candidates:
   1:             args.cover = prompt_select("Select cover image:", cover_candidates, default_index=1)
   1: 
   1:     if interactive:
   1:         _print_checklist(args)
   1:     if not args.docx and interactive:
   1:         args.docx = prompt("DOCX filename in this folder", allow_empty=True)
   1:     if not args.cover and interactive:
   1:         # Offer a numeric pick of images in the folder, else prompt
   1:         cwd = Path.cwd() if not args.docx else Path(args.docx).expanduser().resolve().parent
   1:         img_files = [p.name for p in sorted(cwd.glob("*.jpg"))] + [p.name for p in sorted(cwd.glob("*.jpeg"))] + [p.name for p in sorted(cwd.glob("*.png"))]
   1:         if img_files:
   1:             args.cover = prompt_select("Select cover image:", img_files, default_index=1)
   1:         else:
   1:             args.cover = prompt("Cover filename in this folder (jpg/png)", allow_empty=True)
   1:     if not args.title and interactive:
   1:         args.title = prompt("Book title", allow_empty=True)
   1:     # Ask for author and language (respect provided values)
   1:     if interactive:
   1:         args.author = prompt("Author", default=args.author or "Riley E. Antrobus")
   1:         args.language = prompt("Language (BCP-47)", default=args.language or "en")
   1:     # Defaults already exist for author and language.
   1:     # Optional metadata
   1:     if interactive and (args.seriesName is None):
   1:         args.seriesName = prompt("Series name (optional)", default="", allow_empty=True)
   1:     if interactive and (args.seriesIndex is None) and args.seriesName:
   1:         args.seriesIndex = prompt("Series index (optional)", default="", allow_empty=True)
   1:     # Calibre-compatible sort fields
   1:     if interactive and getattr(args, "title_sort", None) is None:
   1:         setattr(args, "title_sort", prompt("Title sort (optional)", default="", allow_empty=True))
   1:     if interactive and getattr(args, "author_sort", None) is None:
   1:         setattr(args, "author_sort", prompt("Author sort (optional)", default="", allow_empty=True))
   1:     if interactive and args.description is None:
   1:         args.description = prompt("Description (optional)", default="", allow_empty=True)
   1:     if interactive and args.isbn is None:
   1:         args.isbn = prompt("ISBN-13 (optional)", default="", allow_empty=True)
   1:     if interactive and args.publisher is None:
   1:         args.publisher = prompt("Publisher (optional)", default="", allow_empty=True)
   1:     if interactive and args.pubdate is None:
   1:         args.pubdate = prompt("Publication date YYYY-MM-DD (optional)", default="", allow_empty=True)
   1:     if interactive and args.uuid is None:
   1:         args.uuid = prompt("UUID (optional, auto if absent)", default="", allow_empty=True)
   1:     if interactive and args.subjects is None:
   1:         args.subjects = prompt("Subjects (comma-separated, optional)", default="", allow_empty=True)
   1:     if interactive and args.keywords is None:
   1:         args.keywords = prompt("Keywords (comma-separated, optional)", default="", allow_empty=True)
   1: 
   1:     # Conversion/layout options
   1:     if interactive:
   1:         args.split_at = prompt_select("Split at:", ["h1", "h2", "pagebreak"], default_index={"h1":1, "h2":2, "pagebreak":3}.get(args.split_at,1))
   1:         args.theme = prompt_select("Theme:", ["serif", "sans", "printlike"], default_index={"serif":1, "sans":2, "printlike":3}.get(args.theme,1))
   1:         args.hyphenate = prompt_select("Hyphenate:", ["on", "off"], default_index={"on":1, "off":2}.get(args.hyphenate,1))
   1:         args.justify = prompt_select("Justify:", ["on", "off"], default_index={"on":1, "off":2}.get(args.justify,1))
   1:         # Numeric picker for ToC depth
   1:         default_idx = 1 if int(args.toc_depth) == 1 else 2
   1:         sel = prompt_select("ToC depth:", ["1", "2"], default_index=default_idx)
   1:         args.toc_depth = int(sel)
   1:         args.page_list = prompt_select("Include page-list nav?", ["on", "off"], default_index={"on":1,"off":2}.get(args.page_list,2))
   1:         args.page_numbers = prompt_select("Show page number counters?", ["on", "off"], default_index={"on":1,"off":2}.get(args.page_numbers,2))
   1:         args.cover_scale = prompt_select("Cover scaling:", ["contain", "cover"], default_index={"contain":1,"cover":2}.get(args.cover_scale,1))
   1:     # Optional assets
   1:     if interactive and args.css is None:
   1:         # Offer a numeric pick of CSS files in the folder
   1:         base = Path.cwd() if not args.docx else Path(args.docx).expanduser().resolve().parent
   1:         css_files = [p.name for p in sorted(base.glob("*.css"))]
   1:         if css_files:
   1:             choices = ["(none)"] + css_files
   1:             sel = prompt_select("Extra CSS (optional):", choices, default_index=1)
   1:             args.css = "" if sel == "(none)" else sel
   1:         else:
   1:             args.css = ""
   1:     if interactive and args.embed_fonts is None:
   1:         # Find directories that contain TTF/OTF files and offer a pick
   1:         base = Path.cwd() if not args.docx else Path(args.docx).expanduser().resolve().parent
   1:         dir_candidates = []
   1:         for d in sorted([p for p in base.iterdir() if p.is_dir()]):
   1:             if any((d.glob("*.ttf"))) or any((d.glob("*.otf"))):
   1:                 dir_candidates.append(d.name)
   1:         if dir_candidates:
   1:             choices = ["(none)"] + dir_candidates
   1:             sel = prompt_select("Embed fonts directory (optional):", choices, default_index=1)
   1:             args.embed_fonts = "" if sel == "(none)" else sel
   1:         else:
   1:             args.embed_fonts = ""
   1:     if interactive and args.dedication is None:
   1:         base = Path.cwd() if not args.docx else Path(args.docx).expanduser().resolve().parent
   1:         txt_files = [p.name for p in sorted(base.glob("*.txt"))]
   1:         if txt_files:
   1:             choices = ["(none)"] + txt_files
   1:             sel = prompt_select("Dedication .txt (optional):", choices, default_index=1)
   1:             args.dedication = "" if sel == "(none)" else sel
   1:         else:
   1:             args.dedication = ""
   1:     if interactive and args.ack is None:
   1:         base = Path.cwd() if not args.docx else Path(args.docx).expanduser().resolve().parent
   1:         txt_files = [p.name for p in sorted(base.glob("*.txt"))]
   1:         if txt_files:
   1:             choices = ["(none)"] + txt_files
   1:             sel = prompt_select("Acknowledgements .txt (optional):", choices, default_index=1)
   1:             args.ack = "" if sel == "(none)" else sel
   1:         else:
   1:             args.ack = ""
   1:     # Validation
   1:     if interactive:
   1:         epub_default_idx = 1 if getattr(args, "epubcheck", None) in (True, None, "on") else 2
   1:         args.epubcheck = prompt_select("Validate with EPUBCheck if available?", ["on", "off"], default_index=epub_default_idx)
   1: 
   1:     if args.output is None and interactive:
   1:         # Suggest computed output filename and allow override
   1:         suggested = build_output_filename(
   1:             title=args.title,
   1:             series=args.seriesName or None,
   1:             series_index=args.seriesIndex or None,
   1:         )
   1:         out = prompt("Output filename", default=suggested)
   1:         args.output = out
   1: 
   1:     # Auto-generate a metadata.txt template next to DOCX if missing (interactive)
   1:     try:
   1:         if interactive and args.docx:
   1:             docx_path = Path(args.docx).expanduser()
   1:             mpath = docx_path.parent / "metadata.txt"
   1:             if not mpath.exists():
   1:                 tmpl_ns = argparse.Namespace(
   1:                     docx=str(docx_path),
   1:                     cover=args.cover if args.cover else None,
   1:                     output=None,
   1:                     force=False,
   1:                 )
   1:                 run_init_metadata(tmpl_ns)
   1:     except Exception:
   1:         pass
   1: 
   1:     return args
   1: 
   1: 
   1: def _print_metadata_summary(meta: EpubMetadata, opts: BuildOptions, output: Path | None) -> None:
   1:     def mark(val):
   1:         return "[x]" if val else "[ ]"
   1:     print("\n== Metadata Summary ==")
   1:     print(f" {mark(meta.title)} Title: {meta.title or '—'}")
   1:     print(f" {mark(meta.author)} Author: {meta.author or '—'}")
   1:     print(f" {mark(meta.language)} Language: {meta.language or '—'}")
   1:     print(f" {mark(meta.isbn or meta.uuid)} Identifier: {'ISBN '+meta.isbn if meta.isbn else (meta.uuid or '—')}")
   1:     if meta.series:
   1:         print(f" {mark(meta.series)} Series: {meta.series} #{meta.series_index or '—'}")
   1:     print(f" {mark(meta.publisher)} Publisher: {meta.publisher or '—'}")
   1:     print(f" {mark(meta.pubdate)} PubDate: {meta.pubdate.isoformat() if meta.pubdate else '—'}")
   1:     print(f" {mark(bool(meta.subjects))} Subjects: {', '.join(meta.subjects) if meta.subjects else '—'}")
   1:     print(f" {mark(bool(meta.keywords))} Keywords: {', '.join(meta.keywords) if meta.keywords else '—'}")
   1:     print(f" {mark(meta.cover_path)} Cover: {meta.cover_path}")
   1:     print(f" {mark(opts.extra_css)} Extra CSS: {opts.extra_css or '—'}  | Fonts: {opts.embed_fonts_dir or '—'}")
   1:     print(f" Output: {output or '—'}\n")
   1: 
   1: 
   1: def run_build(args: argparse.Namespace) -> int:
   1:     from .convert import docx_to_html, split_html_by_heading, split_html_by_pagebreak
   1:     from .assemble import plan_build, assemble_epub
   1: 
   1:     # Validate paths
   1:     docx_path = Path(args.docx).expanduser().resolve()
   1:     docx_dir = docx_path.parent
   1:     cover_path_candidate = Path(args.cover).expanduser()
   1:     if not cover_path_candidate.is_absolute():
   1:         cover_path_candidate = (docx_dir / cover_path_candidate)
   1:     cover_path = cover_path_candidate.resolve()
   1:     if not docx_path.is_file():
   1:         print(f"Error: DOCX not found: {docx_path}", file=sys.stderr)
   1:         return 2
   1:     if not cover_path.is_file():
   1:         print(f"Error: cover not found: {cover_path}", file=sys.stderr)
   1:         return 2
   1: 
   1:     # Basic validations
   1:     if args.isbn:
   1:         from .metadata import validate_isbn13
   1:         if not validate_isbn13(args.isbn):
   1:             print("Error: Invalid ISBN-13. Provide 13 digits (hyphens allowed) with a valid checksum.", file=sys.stderr)
   1:             return 2
   1:     if docx_path.suffix.lower() != ".docx":
   1:         print("Error: Manuscript must be a .docx file.", file=sys.stderr)
   1:         return 2
   1:     if cover_path.suffix.lower() not in {".jpg", ".jpeg", ".png"}:
   1:         print("Error: Cover must be a .jpg, .jpeg, or .png image.", file=sys.stderr)
   1:         return 2
   1: 
   1:     # Language normalization/validation
   1:     from .metadata import normalize_lang, validate_lang_code
   1:     args.language = normalize_lang(args.language)
   1:     if not validate_lang_code(args.language):
   1:         print("Error: Language must be a BCP-47 code like 'en' or 'en-us'.", file=sys.stderr)
   1:         return 2
   1: 
   1:     if not args.title or str(args.title).strip() == "":
   1:         print("Error: Title is required.", file=sys.stderr)
   1:         return 2
   1: 
   1:     meta = EpubMetadata(
   1:         title=args.title,
   1:         author=args.author or "Riley E. Antrobus",
   1:         language=args.language or "en",
   1:         description=(args.description or None),
   1:         isbn=(args.isbn or None),
   1:         publisher=(args.publisher or None),
   1:         pubdate=parse_date(args.pubdate) if args.pubdate else None,
   1:         uuid=(args.uuid or None),
   1:         series=(args.seriesName or None),
   1:         series_index=(args.seriesIndex or None),
   1:         title_sort=(getattr(args, "title_sort", "") or None),
   1:         author_sort=(getattr(args, "author_sort", "") or None),
   1:         subjects=[s.strip() for s in (args.subjects or "").split(",") if s.strip()],
   1:         keywords=[s.strip() for s in (args.keywords or "").split(",") if s.strip()],
   1:         cover_path=cover_path,
   1:     )
   1: 
   1:     # Resolve optional resource paths relative to DOCX dir
   1:     def _resolve_rel_to_docx(path_str: str | None) -> Path | None:
   1:         if not path_str:
   1:             return None
   1:         p = Path(path_str).expanduser()
   1:         if not p.is_absolute():
   1:             p = (docx_dir / p)
   1:         return p.resolve()
   1: 
   1:     css_path = _resolve_rel_to_docx(args.css) if getattr(args, "css", None) else None
   1:     fonts_dir = _resolve_rel_to_docx(args.embed_fonts) if getattr(args, "embed_fonts", None) else None
   1:     dedication_path = _resolve_rel_to_docx(args.dedication) if getattr(args, "dedication", None) else None
   1:     ack_path = _resolve_rel_to_docx(args.ack) if getattr(args, "ack", None) else None
   1: 
   1:     opts = BuildOptions(
   1:         split_at=args.split_at,
   1:         theme=args.theme,
   1:         embed_fonts_dir=fonts_dir,
   1:         hyphenate=args.hyphenate == "on",
   1:         justify=args.justify == "on",
   1:         toc_depth=int(args.toc_depth),
   1:         page_list=args.page_list == "on",
   1:         extra_css=css_path,
   1:         page_numbers=args.page_numbers == "on",
   1:         epub_version=str(args.epub_version),
   1:         cover_scale=args.cover_scale,
   1:         dedication_txt=dedication_path,
   1:         ack_txt=ack_path,
   1:         inspect=args.inspect,
   1:         dry_run=args.dry_run,
   1:         epubcheck=((args.epubcheck == "on") if isinstance(args.epubcheck, str) else bool(getattr(args, "epubcheck", True))),
   1:     )
   1: 
   1:     try:
   1:         html_chunks, resources = docx_to_html(docx_path)
   1:     except RuntimeError as e:
   1:         print(f"Conversion error: {e}", file=sys.stderr)
   1:         return 2
   1:     # Apply split strategy if needed
   1:     if args.split_at in {"h1", "h2"}:
   1:         combined = "".join(html_chunks)
   1:         html_chunks = split_html_by_heading(combined, level=args.split_at)
   1:     elif args.split_at == "pagebreak":
   1:         combined = "".join(html_chunks)
   1:         html_chunks = split_html_by_pagebreak(combined)
   1: 
   1:     plan = plan_build(meta, opts, html_chunks, resources)
   1:     _print_metadata_summary(meta, opts, None if not args.output else Path(args.output))
   1: 
   1:     if args.dry_run:
   1:         print("-- Dry Run: Planned manifest/spine --")
   1:         for line in plan:
   1:             print(line)
   1:         return 0
   1: 
   1:     # Confirm to proceed if interactive
   1:     interactive = (not getattr(args, "no_prompt", False)) and sys.stdin.isatty()
   1:     if interactive:
   1:         proceed = prompt_bool("Proceed to build now?", default=True)
   1:         if not proceed:
   1:             print("Cancelled.")
   1:             return 1
   1: 
   1:     # Compute default output name if missing
   1:     if not args.output:
   1:         args.output = build_output_filename(
   1:             title=args.title,
   1:             series=args.seriesName or None,
   1:             series_index=args.seriesIndex or None,
   1:         )
   1:     # Resolve output relative to DOCX dir if relative
   1:     out_path = Path(args.output)
   1:     if not out_path.is_absolute():
   1:         out_path = (docx_dir / out_path)
   1:     # Sanitize name and ensure .epub extension
   1:     name = out_path.name
   1:     if not name.lower().endswith('.epub'):
   1:         name = sanitize_filename(name) + '.epub'
   1:     out_path = out_path.with_name(name)
   1:     output = out_path.resolve()
   1:     assemble_epub(meta, opts, html_chunks, resources, output)
   1:     print(f"Wrote: {output}")
   1:     if opts.inspect:
   1:         print("Inspect folder emitted for debugging.")
   1:     return 0
   1: 
   1: 
   1: def run_init_metadata(args: argparse.Namespace) -> int:
   1:     docx_path = Path(args.docx).expanduser().resolve()
   1:     if not docx_path.is_file() or docx_path.suffix.lower() != ".docx":
   1:         print(f"Error: DOCX not found or not a .docx file: {docx_path}", file=sys.stderr)
   1:         return 2
   1:     out_path = Path(args.output).expanduser().resolve() if args.output else docx_path.parent / "metadata.txt"
   1:     if out_path.exists() and not args.force:
   1:         print(f"Refusing to overwrite existing file: {out_path}. Use --force to overwrite.", file=sys.stderr)
   1:         return 2
   1: 
   1:     title_guess = docx_path.stem.replace("_", " ").replace("-", " ").strip().title()
   1:     from .metadata import build_output_filename
   1:     output_guess = build_output_filename(title_guess, None, None)
   1: 
   1:     lines = [
   1:         "# Docx2Shelf metadata template",
   1:         "# Lines starting with # are ignored. Keys are case-insensitive.",
   1:         "# Use key: value or key=value. Paths can be relative to this DOCX folder.",
   1:         "",
   1:         f"Title: {title_guess}",
   1:         "Author: Riley E. Antrobus",
   1:         "Language: en",
   1:         "",
   1:         "# Optional metadata",
   1:         "SeriesName:",
   1:         "SeriesIndex:",
   1:         "Title-Sort:",
   1:         "Author-Sort:",
   1:         "Description:",
   1:         "ISBN:",
   1:         "Publisher:",
   1:         "PubDate: 2024-01-01",
   1:         "UUID:",
   1:         "Subjects: ",
   1:         "Keywords: ",
   1:         "",
   1:         "# Assets",
   1:         f"Cover: {args.cover or ''}",
   1:         "CSS:",
   1:         "Embed-Fonts:",
   1:         "",
   1:         "# Conversion & layout",
   1:         "Theme: serif",
   1:         "Split-At: h1",
   1:         "ToC_Depth: 2",
   1:         "Hyphenate: on",
   1:         "Justify: on",
   1:         "Page-List: off",
   1:         "Page-Numbers: off",
   1:         "Cover-Scale: contain",
   1:         "",
   1:         "# Output & validation",
   1:         f"Output: {output_guess}",
   1:         "EPUBCheck: on",
   1:         "",
   1:     ]
   1:     out_path.write_text("\n".join(lines), encoding="utf-8")
   1:     print(f"Wrote template: {out_path}")
   1:     return 0
   1: 
   1: 
   1: def main(argv: Optional[list[str]] = None) -> int:
   1:     if argv is None:
   1:         argv = sys.argv[1:]
   1:     if not argv:
   1:         # Default to interactive build when no args are provided
   1:         argv = ["build"]
   1:     parser = _arg_parser()
   1:     args = parser.parse_args(argv)
   1: 
   1:     if args.command == "build":
   1:         args = _prompt_missing(args)
   1:         return run_build(args)
   1:     if args.command == "init-metadata":
   1:         return run_init_metadata(args)
   1: 
   1:     parser.print_help()
   1:     return 1
   1: 
   1: 
   1: if __name__ == "__main__":  # pragma: no cover
   1:     raise SystemExit(main())
